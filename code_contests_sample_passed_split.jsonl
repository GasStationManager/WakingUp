{"function_signature": "def beautiful_table (n k : Nat) (h1 : n ≥ 1) (h2 : k ≥ 1) : List (List Int)", "property_name": "beautiful_table_prop", "property_def": "def sum_list (l : List Int) : Int :=\n  l.foldl (· + ·) 0\n\ndef all_elements_valid (m : List (List Int)) : Prop :=\n  m.all (λ row => row.all (λ x => x.natAbs ≤ 1000))\n\ndef row_sums_valid (m : List (List Int)) (k : Nat) : Prop :=\n  m.all (λ row => sum_list row = k)\n\ndef get_column (m : List (List Int)) (j : Nat) : List Int :=\n  m.map (λ row => row[j]!)\n\ndef col_sums_valid (m : List (List Int)) (n k : Nat) : Prop :=\n  List.range n |>.all (λ j => sum_list (get_column m j) = k)\n\ndef is_square_matrix (m : List (List Int)) (n : Nat) : Prop :=\n  m.length = n ∧ m.all (λ row => row.length = n)\n\ndef beautiful_table_prop (n k : Nat) (h1 : n ≥ 1) (h2 : k ≥ 1) (out : List (List Int)) : Prop :=\n  is_square_matrix out n ∧ \n  all_elements_valid out ∧\n  row_sums_valid out k ∧\n  col_sums_valid out n k", "theorem_signature": "theorem beautiful_table_spec (n k : Nat) (h1 : n ≥ 1) (h2 : k ≥ 1) : beautiful_table_prop n k h1 h2 (beautiful_table n k h1 h2)", "tests": [{"input": "2 4 (by decide) (by decide)", "output": "[[1,3],[3,1]]"}, {"input": "4 7 (by decide) (by decide)", "output": "[[7,0,0,0],[0,7,0,0],[0,0,7,0],[0,0,0,7]]"}], "description": "Levko loves tables that consist of n rows and n columns very much. He especially loves beautiful tables. A table is beautiful to Levko if the sum of elements in each row and column of the table equals k.\n\nUnfortunately, he doesn't know any such table. Your task is to help him to find at least one of them. \n\nInput\n\nThe single line contains two integers, n and k (1 ≤ n ≤ 100, 1 ≤ k ≤ 1000).\n\nOutput\n\nPrint any beautiful table. Levko doesn't like too big numbers, so all elements of the table mustn't exceed 1000 in their absolute value.\n\nIf there are multiple suitable tables, you are allowed to print any of them.\n\nExamples\n\nInput\n\n2 4\n\n\nOutput\n\n1 3\n3 1\n\n\nInput\n\n4 7\n\n\nOutput\n\n2 1 0 4\n4 0 2 1\n1 3 3 0\n0 3 2 2\n\nNote\n\nIn the first sample the sum in the first row is 1 + 3 = 4, in the second row — 3 + 1 = 4, in the first column — 1 + 3 = 4 and in the second column — 3 + 1 = 4. There are other beautiful tables for this sample.\n\nIn the second sample the sum of elements in each row and each column equals 7. Besides, there are other tables that meet the statement requirements.", "test_results": [{"status": "pass", "feedback": "/var/tmp/tmp9lzwk67b/true.lean:22:46: warning: unused variable `h1`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`\n/var/tmp/tmp9lzwk67b/true.lean:22:59: warning: unused variable `h2`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`"}, {"status": "pass", "feedback": "/var/tmp/tmpht93ypxa/true.lean:22:46: warning: unused variable `h1`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`\n/var/tmp/tmpht93ypxa/true.lean:22:59: warning: unused variable `h2`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`"}], "status": "pass"}
{"function_signature": "def escape_room (n m: Nat) (input fingerprints: List Nat) : List Nat", "property_name": "escape_room_prop", "property_def": "def isSubsequence (s t: List Nat) : Bool :=\n  match s, t with\n  | [], _ => true\n  | x::xs, [] => false\n  | x::xs, y::ys => if x = y \n                    then isSubsequence xs ys\n                    else isSubsequence (x::xs) ys\n\ndef allIn (xs: List Nat) (ys: List Nat) : Bool :=\n  xs.all (fun x => ys.contains x)\n\ndef noLongerValidSubseq (input fingerprints: List Nat) (out: List Nat) : Bool :=\n  let candidates := input.filterMap (fun x => if fingerprints.contains x then some x else none)\n  candidates.length ≤ out.length\n\ndef escape_room_prop (n m: Nat) (input fingerprints out: List Nat) : Prop := \n  n ≥ 1 ∧ n ≤ 10 ∧ m ≥ 1 ∧ m ≤ 10 ∧ \n  input.length = n ∧ fingerprints.length = m ∧\n  isSubsequence out input ∧ \n  allIn out fingerprints ∧\n  noLongerValidSubseq input fingerprints out", "theorem_signature": "theorem escape_room_spec (n m: Nat) (input fingerprints: List Nat) : escape_room_prop n m input fingerprints (escape_room n m input fingerprints)", "tests": [{"input": "7 3 [3,5,7,1,6,2,8] [1,2,7]", "output": "[7,1,2]"}, {"input": "4 4 [3,4,1,0] [0,1,7,9]", "output": "[1,0]"}], "description": "You are locked in a room with a door that has a keypad with 10 keys corresponding to digits from 0 to 9. To escape from the room, you need to enter a correct code. You also have a sequence of digits.\n\nSome keys on the keypad have fingerprints. You believe the correct code is the longest not necessarily contiguous subsequence of the sequence you have that only contains digits with fingerprints on the corresponding keys. Find such code.\n\nInput\n\nThe first line contains two integers n and m (1 ≤ n, m ≤ 10) representing the number of digits in the sequence you have and the number of keys on the keypad that have fingerprints.\n\nThe next line contains n distinct space-separated integers x_1, x_2, …, x_n (0 ≤ x_i ≤ 9) representing the sequence.\n\nThe next line contains m distinct space-separated integers y_1, y_2, …, y_m (0 ≤ y_i ≤ 9) — the keys with fingerprints.\n\nOutput\n\nIn a single line print a space-separated sequence of integers representing the code. If the resulting sequence is empty, both printing nothing and printing a single line break is acceptable.\n\nExamples\n\nInput\n\n7 3\n3 5 7 1 6 2 8\n1 2 7\n\n\nOutput\n\n7 1 2\n\n\nInput\n\n4 4\n3 4 1 0\n0 1 7 9\n\n\nOutput\n\n1 0\n\nNote\n\nIn the first example, the only digits with fingerprints are 1, 2 and 7. All three of them appear in the sequence you know, 7 first, then 1 and then 2. Therefore the output is 7 1 2. Note that the order is important, and shall be the same as the order in the original sequence.\n\nIn the second example digits 0, 1, 7 and 9 have fingerprints, however only 0 and 1 appear in the original sequence. 1 appears earlier, so the output is 1 0. Again, the order is important.", "test_results": [{"status": "pass", "feedback": "/var/tmp/tmpces0xtlt/true.lean:7:4: warning: unused variable `x`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`\n/var/tmp/tmpces0xtlt/true.lean:7:7: warning: unused variable `xs`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`"}, {"status": "pass", "feedback": "/var/tmp/tmp4zcdecil/true.lean:7:4: warning: unused variable `x`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`\n/var/tmp/tmp4zcdecil/true.lean:7:7: warning: unused variable `xs`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`"}], "status": "pass"}
{"function_signature": "def chocolate_count (n : Nat) (h : n > 0 ∧ n ≤ 100) (grid : Array (Array Char)) : Nat", "property_name": "chocolate_count_prop", "property_def": "def countPairs (n : Nat) : Nat :=\n  match n with\n  | 0 => 0\n  | 1 => 0\n  | k => (k * (k-1)) / 2\n\ndef countChocolatesInRow (grid : Array (Array Char)) (row : Nat) : Nat :=\n  let rowArr := grid[row]!\n  rowArr.foldl (fun acc c => if c == 'C' then acc + 1 else acc) 0\n\ndef countChocolatesInCol (grid : Array (Array Char)) (col : Nat) : Nat :=\n  grid.foldl (fun acc row => if row[col]! == 'C' then acc + 1 else acc) 0\n\ndef chocolate_count_prop (n : Nat) (h : n > 0 ∧ n ≤ 100) (grid : Array (Array Char)) (out : Nat) : Prop :=\n  let rowPairs := (Array.range n).foldl\n    (fun acc row => acc + countPairs (countChocolatesInRow grid row)) 0\n  let colPairs := (Array.range n).foldl\n    (fun acc col => acc + countPairs (countChocolatesInCol grid col)) 0\n  rowPairs + colPairs = out", "theorem_signature": "theorem chocolate_count_spec (n : Nat) (h : n > 0 ∧ n ≤ 100) (grid : Array (Array Char)) : chocolate_count_prop n h grid (chocolate_count n h grid)", "tests": [{"input": "3 (by decide) #[#['.', 'C', 'C'], #['C', '.', '.'], #['C', '.', 'C']]", "output": "4"}, {"input": "4 (by decide) #[#['C', 'C', '.', '.'], #['C', '.', '.', 'C'], #['.', 'C', 'C', '.'], #['.', 'C', 'C', '.']]", "output": "9"}], "description": "Door's family is going celebrate Famil Doors's birthday party. They love Famil Door so they are planning to make his birthday cake weird!\n\nThe cake is a n × n square consisting of equal squares with side length 1. Each square is either empty or consists of a single chocolate. They bought the cake and randomly started to put the chocolates on the cake. The value of Famil Door's happiness will be equal to the number of pairs of cells with chocolates that are in the same row or in the same column of the cake. Famil Doors's family is wondering what is the amount of happiness of Famil going to be?\n\nPlease, note that any pair can be counted no more than once, as two different cells can't share both the same row and the same column.\n\nInput\n\nIn the first line of the input, you are given a single integer n (1 ≤ n ≤ 100) — the length of the side of the cake.\n\nThen follow n lines, each containing n characters. Empty cells are denoted with '.', while cells that contain chocolates are denoted by 'C'.\n\nOutput\n\nPrint the value of Famil Door's happiness, i.e. the number of pairs of chocolate pieces that share the same row or the same column.\n\nExamples\n\nInput\n\n3\n.CC\nC..\nC.C\n\n\nOutput\n\n4\n\n\nInput\n\n4\nCC..\nC..C\n.CC.\n.CC.\n\n\nOutput\n\n9\n\nNote\n\nIf we number rows from top to bottom and columns from left to right, then, pieces that share the same row in the first sample are: \n\n  1. (1, 2) and (1, 3)\n  2. (3, 1) and (3, 3)\n\nPieces that share the same column are: \n  1. (2, 1) and (3, 1)\n  2. (1, 3) and (3, 3)", "test_results": [{"status": "pass", "feedback": "/var/tmp/tmpfki91zb5/true.lean:17:44: warning: unused variable `h`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`"}, {"status": "pass", "feedback": "/var/tmp/tmpsyu3jacc/true.lean:17:44: warning: unused variable `h`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`"}], "status": "pass"}
{"function_signature": "def findWinner (teams : List String) (h : teams.length ≤ 100) (h2 : teams.length > 0) : String", "property_name": "findWinner_prop", "property_def": "def countOccurrences (x : String) (lst : List String) : Nat :=\n  lst.filter (· == x) |>.length\n\ndef getUniqueTeams (teams : List String) : List String :=\n  teams.eraseDups\n\ndef findWinner_prop (teams : List String) (h : teams.length ≤ 100) (h2 : teams.length > 0) (out : String) : Prop := \n  let uniqueTeams := getUniqueTeams teams\n  (uniqueTeams.contains out) ∧ \n  ∀ other : String, uniqueTeams.contains other → \n    countOccurrences out teams ≥ countOccurrences other teams ∧\n    (other ≠ out → countOccurrences out teams > countOccurrences other teams)", "theorem_signature": "theorem findWinner_spec (teams : List String) (h : teams.length ≤ 100) (h2 : teams.length > 0) : findWinner_prop teams h h2 (findWinner teams h h2)", "tests": [{"input": "[\"ABC\"] (by decide) (by decide)", "output": "\"ABC\""}, {"input": "[\"A\", \"ABA\", \"ABA\", \"A\", \"A\"] (by decide) (by decide)", "output": "\"A\""}], "description": "One day Vasya decided to have a look at the results of Berland 1910 Football Championship’s finals. Unfortunately he didn't find the overall score of the match; however, he got hold of a profound description of the match's process. On the whole there are n lines in that description each of which described one goal. Every goal was marked with the name of the team that had scored it. Help Vasya, learn the name of the team that won the finals. It is guaranteed that the match did not end in a tie.\n\nInput\n\nThe first line contains an integer n (1 ≤ n ≤ 100) — the number of lines in the description. Then follow n lines — for each goal the names of the teams that scored it. The names are non-empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.\n\nOutput\n\nPrint the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.\n\nExamples\n\nInput\n\n1\nABC\n\n\nOutput\n\nABC\n\n\nInput\n\n5\nA\nABA\nABA\nA\nA\n\n\nOutput\n\nA", "test_results": [{"status": "pass", "feedback": "/var/tmp/tmpevwe_2_3/true.lean:10:51: warning: unused variable `h`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`\n/var/tmp/tmpevwe_2_3/true.lean:10:76: warning: unused variable `h2`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`"}, {"status": "pass", "feedback": "/var/tmp/tmpv27rqov_/true.lean:10:51: warning: unused variable `h`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`\n/var/tmp/tmpv27rqov_/true.lean:10:76: warning: unused variable `h2`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`"}], "status": "pass"}
{"function_signature": "def min_instability (n : Nat) (arr : Array Nat) : Nat", "property_name": "min_instability_prop", "property_def": "def array_max (arr : Array Nat) : Nat :=\n  arr.foldl max 0\n\ndef array_min (arr : Array Nat) : Nat :=\n  arr.foldl min (arr[0]!)\n\ndef instability (arr : Array Nat) : Nat :=\n  array_max arr - array_min arr\n\ndef valid_input (n : Nat) (arr : Array Nat) : Prop :=\n  n = arr.size ∧ n ≥ 2 ∧ n ≤ 100000 ∧\n  ∀ i, i < arr.size → arr[i]! ≥ 1 ∧ arr[i]! ≤ 100000\n\ndef remove_at (arr : Array Nat) (idx : Nat) : Array Nat :=\n  arr.eraseIdx idx\n\ndef min_instability_prop (n : Nat) (arr : Array Nat) (out : Nat) : Prop :=\n  valid_input n arr →\n  (∃ idx : Nat, idx < arr.size ∧\n    let removed := remove_at arr idx\n    (∀ other_idx : Nat, other_idx < arr.size →\n      instability removed ≤ instability (remove_at arr other_idx)) ∧\n    instability removed = out)", "theorem_signature": "theorem min_instability_spec (n : Nat) (arr : Array Nat) : min_instability_prop n arr (min_instability n arr)", "tests": [{"input": "4 #[1,3,3,7]", "output": "2"}], "description": "You are given an array a consisting of n integer numbers.\n\nLet instability of the array be the following value: max_{i = 1}^{n} a_i - min_{i = 1}^{n} a_i.\n\nYou have to remove exactly one element from this array to minimize instability of the resulting (n-1)-elements array. Your task is to calculate the minimum possible instability.\n\nInput\n\nThe first line of the input contains one integer n (2 ≤ n ≤ 10^5) — the number of elements in the array a.\n\nThe second line of the input contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^5) — elements of the array a.\n\nOutput\n\nPrint one integer — the minimum possible instability of the array if you have to remove exactly one element from the array a.\n\nExamples\n\nInput\n\n\n4\n1 3 3 7\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n2\n1 100000\n\n\nOutput\n\n\n0\n\nNote\n\nIn the first example you can remove 7 then instability of the remaining array will be 3 - 1 = 2.\n\nIn the second example you can remove either 1 or 100000 then instability of the remaining array will be 100000 - 100000 = 0 and 1 - 1 = 0 correspondingly.", "test_results": [{"status": "pass", "feedback": ""}], "status": "pass"}
{"function_signature": "def countRoomsForTwo (rooms: List (Nat × Nat)) : Nat", "property_name": "countRoomsForTwo_prop", "property_def": "def valid_room (p q : Nat) : Prop := p ≤ q ∧ q ≤ 100\n\ndef countRoomsForTwo_prop (rooms: List (Nat × Nat)) (out: Nat) : Prop :=\n  (∀ r ∈ rooms, valid_room r.1 r.2) ∧\n  out = (rooms.filter (λ r => r.2 - r.1 ≥ 2)).length", "theorem_signature": "theorem countRoomsForTwo_spec (rooms: List (Nat × Nat)) : countRoomsForTwo_prop rooms (countRoomsForTwo rooms)", "tests": [{"input": "[(1,1), (2,2), (3,3)]", "output": "0"}, {"input": "[(1,10), (0,10), (10,10)]", "output": "2"}], "description": "George has recently entered the BSUCP (Berland State University for Cool Programmers). George has a friend Alex who has also entered the university. Now they are moving into a dormitory. \n\nGeorge and Alex want to live in the same room. The dormitory has n rooms in total. At the moment the i-th room has pi people living in it and the room can accommodate qi people in total (pi ≤ qi). Your task is to count how many rooms has free place for both George and Alex.\n\nInput\n\nThe first line contains a single integer n (1 ≤ n ≤ 100) — the number of rooms.\n\nThe i-th of the next n lines contains two integers pi and qi (0 ≤ pi ≤ qi ≤ 100) — the number of people who already live in the i-th room and the room's capacity.\n\nOutput\n\nPrint a single integer — the number of rooms where George and Alex can move in.\n\nExamples\n\nInput\n\n3\n1 1\n2 2\n3 3\n\n\nOutput\n\n0\n\n\nInput\n\n3\n1 10\n0 10\n10 10\n\n\nOutput\n\n2", "test_results": [{"status": "pass", "feedback": ""}, {"status": "pass", "feedback": ""}], "status": "pass"}
{"function_signature": "def best_hp_category (x : Nat) (h : 30 ≤ x ∧ x ≤ 100) : Nat × Char", "property_name": "best_hp_category_prop", "property_def": "def getCategory (n : Nat) : Char :=\n  match n % 4 with\n  | 1 => 'A'\n  | 3 => 'B'\n  | 2 => 'C'\n  | _ => 'D'\n\ndef categoryRank (c : Char) : Nat :=\n  match c with\n  | 'A' => 3\n  | 'B' => 2\n  | 'C' => 1\n  | 'D' => 0\n  | _ => 0\n\ndef isValidCategory (c : Char) : Bool :=\n  c = 'A' || c = 'B' || c = 'C' || c = 'D'\n\ndef best_hp_category_prop (x : Nat) (h : 30 ≤ x ∧ x ≤ 100) (out : Nat × Char) : Prop := \n  let (inc, cat) := out\n  (30 ≤ x ∧ x ≤ 100) ∧\n  inc ≤ 2 ∧ \n  isValidCategory cat ∧\n  getCategory (x + inc) = cat ∧\n  ∀ i : Nat, i ≤ 2 → categoryRank (getCategory (x + i)) ≤ categoryRank cat", "theorem_signature": "theorem best_hp_category_spec (x : Nat) (h : 30 ≤ x ∧ x ≤ 100) : best_hp_category_prop x h (best_hp_category x h)", "tests": [{"input": "33 (by decide)", "output": "(0, 'A')"}, {"input": "98 (by decide)", "output": "(1, 'B')"}], "description": "Tokitsukaze is one of the characters in the game \"Kantai Collection\". In this game, every character has a common attribute — health points, shortened to HP.\n\nIn general, different values of HP are grouped into 4 categories:\n\n  * Category A if HP is in the form of (4 n + 1), that is, when divided by 4, the remainder is 1; \n  * Category B if HP is in the form of (4 n + 3), that is, when divided by 4, the remainder is 3; \n  * Category C if HP is in the form of (4 n + 2), that is, when divided by 4, the remainder is 2; \n  * Category D if HP is in the form of 4 n, that is, when divided by 4, the remainder is 0. \n\n\n\nThe above-mentioned n can be any integer.\n\nThese 4 categories ordered from highest to lowest as A > B > C > D, which means category A is the highest and category D is the lowest.\n\nWhile playing the game, players can increase the HP of the character. Now, Tokitsukaze wants you to increase her HP by at most 2 (that is, either by 0, 1 or 2). How much should she increase her HP so that it has the highest possible category?\n\nInput\n\nThe only line contains a single integer x (30 ≤ x ≤ 100) — the value Tokitsukaze's HP currently.\n\nOutput\n\nPrint an integer a (0 ≤ a ≤ 2) and an uppercase letter b (b ∈ { A, B, C, D }), representing that the best way is to increase her HP by a, and then the category becomes b.\n\nNote that the output characters are case-sensitive.\n\nExamples\n\nInput\n\n\n33\n\n\nOutput\n\n\n0 A\n\n\nInput\n\n\n98\n\n\nOutput\n\n\n1 B\n\nNote\n\nFor the first example, the category of Tokitsukaze's HP is already A, so you don't need to enhance her ability.\n\nFor the second example:\n\n  * If you don't increase her HP, its value is still 98, which equals to (4 × 24 + 2), and its category is C. \n  * If you increase her HP by 1, its value becomes 99, which equals to (4 × 24 + 3), and its category becomes B. \n  * If you increase her HP by 2, its value becomes 100, which equals to (4 × 25), and its category becomes D. \n\n\n\nTherefore, the best way is to increase her HP by 1 so that the category of her HP becomes B.", "test_results": [{"status": "pass", "feedback": "/var/tmp/tmpdzj0rqyy/true.lean:22:45: warning: unused variable `h`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`"}, {"status": "pass", "feedback": "/var/tmp/tmptxxak3p0/true.lean:22:45: warning: unused variable `h`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`"}], "status": "pass"}
{"function_signature": "def dice_game (a b : Nat) (h1 : 1 ≤ a ∧ a ≤ 6) (h2 : 1 ≤ b ∧ b ≤ 6) : Nat × Nat × Nat", "property_name": "dice_game_prop", "property_def": "def abs_diff (x y : Nat) : Nat := \n  if x ≥ y then x - y else y - x\n\ndef compare_distances (a b x : Nat) : Nat :=\n  let dist_a := abs_diff a x\n  let dist_b := abs_diff b x\n  if dist_a < dist_b then 0     -- first player wins\n  else if dist_a = dist_b then 1 -- draw\n  else 2                         -- second player wins\n\ndef count_wins (a b : Nat) : List Nat → Nat\n  | [] => 0\n  | x::xs => (if compare_distances a b (x+1) = 0 then 1 else 0) + count_wins a b xs\n\ndef count_draws (a b : Nat) : List Nat → Nat\n  | [] => 0\n  | x::xs => (if compare_distances a b (x+1) = 1 then 1 else 0) + count_draws a b xs\n\ndef count_losses (a b : Nat) : List Nat → Nat\n  | [] => 0\n  | x::xs => (if compare_distances a b (x+1) = 2 then 1 else 0) + count_losses a b xs\n\ndef count_outcomes (a b wins draws losses : Nat) : Prop :=\n  wins = count_wins a b (List.range 6) ∧\n  draws = count_draws a b (List.range 6) ∧\n  losses = count_losses a b (List.range 6)\n\ndef dice_game_prop (a b : Nat) (h1 : 1 ≤ a ∧ a ≤ 6) (h2 : 1 ≤ b ∧ b ≤ 6) (out : Nat × Nat × Nat) : Prop := \n  let (wins, draws, losses) := out\n  count_outcomes a b wins draws losses ∧\n  wins + draws + losses = 6", "theorem_signature": "theorem dice_game_spec (a b : Nat) (h1 : 1 ≤ a ∧ a ≤ 6) (h2 : 1 ≤ b ∧ b ≤ 6) : dice_game_prop a b h1 h2 (dice_game a b h1 h2)", "tests": [{"input": "2 5 (by decide) (by decide)", "output": "(3, 0, 3)"}, {"input": "2 4 (by decide) (by decide)", "output": "(2, 1, 3)"}], "description": "Two players are playing a game. First each of them writes an integer from 1 to 6, and then a dice is thrown. The player whose written number got closer to the number on the dice wins. If both payers have the same difference, it's a draw.\n\nThe first player wrote number a, the second player wrote number b. How many ways to throw a dice are there, at which the first player wins, or there is a draw, or the second player wins?\n\nInput\n\nThe single line contains two integers a and b (1 ≤ a, b ≤ 6) — the numbers written on the paper by the first and second player, correspondingly.\n\nOutput\n\nPrint three integers: the number of ways to throw the dice at which the first player wins, the game ends with a draw or the second player wins, correspondingly.\n\nExamples\n\nInput\n\n2 5\n\n\nOutput\n\n3 0 3\n\n\nInput\n\n2 4\n\n\nOutput\n\n2 1 3\n\nNote\n\nThe dice is a standard cube-shaped six-sided object with each side containing a number from 1 to 6, and where all numbers on all sides are distinct.\n\nYou can assume that number a is closer to number x than number b, if |a - x| < |b - x|.", "test_results": [{"status": "pass", "feedback": "/var/tmp/tmpgrkko3n_/true.lean:31:40: warning: unused variable `h1`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`\n/var/tmp/tmpgrkko3n_/true.lean:31:61: warning: unused variable `h2`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`"}, {"status": "pass", "feedback": "/var/tmp/tmpq9ex4vdn/true.lean:31:40: warning: unused variable `h1`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`\n/var/tmp/tmpq9ex4vdn/true.lean:31:61: warning: unused variable `h2`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`"}], "status": "pass"}
