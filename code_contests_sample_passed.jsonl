{"function_signature": "def beautifulTable (n k : Nat) : List (List Int)", "property_name": "beautifulTable_prop", "property_def": "def all_le (l : List Int) (bound : Int) : Bool :=\n  l.all (fun x => x.natAbs ≤ bound)\n\ndef list_sum (l : List Int) : Int :=\n  l.foldl (· + ·) 0\n\ndef all_lists_sum_to (lists : List (List Int)) (target : Int) : Bool :=\n  lists.all (fun l => list_sum l = target)\n\ndef get_column (matrix : List (List Int)) (j : Nat) : List Int :=\n  matrix.map (fun row => row[j]!)\n\ndef get_columns (matrix : List (List Int)) : List (List Int) :=\n  let n := matrix[0]!.length\n  List.range n |>.map (fun j => get_column matrix j)\n\ndef beautifulTable_prop (n k : Nat) (out : List (List Int)) : Prop :=\n  let k_int := Int.ofNat k\n  -- Matrix is n×n\n  out.length = n ∧ \n  out.all (fun row => row.length = n) ∧\n  -- All elements ≤ 1000\n  out.all (fun row => all_le row 1000) ∧\n  -- All rows sum to k\n  all_lists_sum_to out k_int ∧\n  -- All columns sum to k\n  all_lists_sum_to (get_columns out) k_int", "theorem_signature": "theorem beautifulTable_spec (n k : Nat) : beautifulTable_prop n k (beautifulTable n k)", "tests": ["4 7 [[7,0,0,0], [0,7,0,0], [0,0,7,0], [0,0,0,7]]", "2 4 [[4,0], [0,4]]"], "description": "Levko loves tables that consist of n rows and n columns very much. He especially loves beautiful tables. A table is beautiful to Levko if the sum of elements in each row and column of the table equals k.\n\nUnfortunately, he doesn't know any such table. Your task is to help him to find at least one of them. \n\nInput\n\nThe single line contains two integers, n and k (1 ≤ n ≤ 100, 1 ≤ k ≤ 1000).\n\nOutput\n\nPrint any beautiful table. Levko doesn't like too big numbers, so all elements of the table mustn't exceed 1000 in their absolute value.\n\nIf there are multiple suitable tables, you are allowed to print any of them.\n\nExamples\n\nInput\n\n2 4\n\n\nOutput\n\n1 3\n3 1\n\n\nInput\n\n4 7\n\n\nOutput\n\n2 1 0 4\n4 0 2 1\n1 3 3 0\n0 3 2 2\n\nNote\n\nIn the first sample the sum in the first row is 1 + 3 = 4, in the second row — 3 + 1 = 4, in the first column — 1 + 3 = 4 and in the second column — 3 + 1 = 4. There are other beautiful tables for this sample.\n\nIn the second sample the sum of elements in each row and each column equals 7. Besides, there are other tables that meet the statement requirements.", "test_results": [{"status": "pass", "feedback": ""}, {"status": "pass", "feedback": ""}], "status": "pass"}
{"function_signature": "def min_shovels (k r : Nat) : Nat", "property_name": "min_shovels_prop", "property_def": "def isPayableWith10sAndR (amount r : Nat) : Bool :=\n  let remainder := amount % 10\n  remainder == 0 || remainder == r\n\ndef min_shovels_prop (k r out : Nat) : Prop := \n  -- out must be positive\n  out > 0 ∧ \n  -- amount must be payable\n  isPayableWith10sAndR (k * out) r ∧\n  -- must be minimum\n  ∀ n, n > 0 → n < out → ¬(isPayableWith10sAndR (k * n) r)", "theorem_signature": "theorem min_shovels_spec (k r : Nat) (h1 : k > 0) (h2 : r > 0) (h3 : r < 10) : min_shovels_prop k r (min_shovels k r)", "tests": ["237 7 1", "15 2 2", "117 3 9"], "description": "Polycarp urgently needs a shovel! He comes to the shop and chooses an appropriate one. The shovel that Policarp chooses is sold for k burles. Assume that there is an unlimited number of such shovels in the shop.\n\nIn his pocket Polycarp has an unlimited number of \"10-burle coins\" and exactly one coin of r burles (1 ≤ r ≤ 9).\n\nWhat is the minimum number of shovels Polycarp has to buy so that he can pay for the purchase without any change? It is obvious that he can pay for 10 shovels without any change (by paying the requied amount of 10-burle coins and not using the coin of r burles). But perhaps he can buy fewer shovels and pay without any change. Note that Polycarp should buy at least one shovel.\n\nInput\n\nThe single line of input contains two integers k and r (1 ≤ k ≤ 1000, 1 ≤ r ≤ 9) — the price of one shovel and the denomination of the coin in Polycarp's pocket that is different from \"10-burle coins\". \n\nRemember that he has an unlimited number of coins in the denomination of 10, that is, Polycarp has enough money to buy any number of shovels.\n\nOutput\n\nPrint the required minimum number of shovels Polycarp has to buy so that he can pay for them without any change. \n\nExamples\n\nInput\n\n117 3\n\n\nOutput\n\n9\n\n\nInput\n\n237 7\n\n\nOutput\n\n1\n\n\nInput\n\n15 2\n\n\nOutput\n\n2\n\nNote\n\nIn the first example Polycarp can buy 9 shovels and pay 9·117 = 1053 burles. Indeed, he can pay this sum by using 10-burle coins and one 3-burle coin. He can't buy fewer shovels without any change.\n\nIn the second example it is enough for Polycarp to buy one shovel.\n\nIn the third example Polycarp should buy two shovels and pay 2·15 = 30 burles. It is obvious that he can pay this sum without any change. ", "test_results": [{"status": "pass", "feedback": ""}, {"status": "pass", "feedback": ""}, {"status": "pass", "feedback": ""}], "status": "pass"}
{"function_signature": "def vote_result (x y z : Nat) : String", "property_name": "vote_result_prop", "property_def": "def vote_result_prop (x y z : Nat) (out : String) : Prop :=\n  (out = \"+\" ∧ ∀ k : Nat, k ≤ z → x + k > y + (z - k)) ∨\n  (out = \"-\" ∧ ∀ k : Nat, k ≤ z → y + (z - k) > x + k) ∨\n  (out = \"0\" ∧ ∀ k : Nat, k ≤ z → x + k = y + (z - k)) ∨\n  (out = \"?\" ∧ ∃ k1 k2 : Nat, k1 ≤ z ∧ k2 ≤ z ∧\n    ((x + k1 > y + (z - k1) ∧ x + k2 < y + (z - k2)) ∨\n     (x + k1 = y + (z - k1) ∧ x + k2 ≠ y + (z - k2)) ∨\n     (x + k1 < y + (z - k1) ∧ x + k2 > y + (z - k2))))", "theorem_signature": "theorem vote_result_spec (x y z : Nat) : vote_result_prop x y z (vote_result x y z)", "tests": ["3 7 0 \"-\"", "1 1 0 \"0\"", "0 0 1 \"?\"", "2 0 1 \"+\""], "description": "Nauuo is a girl who loves writing comments.\n\nOne day, she posted a comment on Codeforces, wondering whether she would get upvotes or downvotes.\n\nIt's known that there were x persons who would upvote, y persons who would downvote, and there were also another z persons who would vote, but you don't know whether they would upvote or downvote. Note that each of the x+y+z people would vote exactly one time.\n\nThere are three different results: if there are more people upvote than downvote, the result will be \"+\"; if there are more people downvote than upvote, the result will be \"-\"; otherwise the result will be \"0\".\n\nBecause of the z unknown persons, the result may be uncertain (i.e. there are more than one possible results). More formally, the result is uncertain if and only if there exist two different situations of how the z persons vote, that the results are different in the two situations.\n\nTell Nauuo the result or report that the result is uncertain.\n\nInput\n\nThe only line contains three integers x, y, z (0≤ x,y,z≤100), corresponding to the number of persons who would upvote, downvote or unknown.\n\nOutput\n\nIf there is only one possible result, print the result : \"+\", \"-\" or \"0\".\n\nOtherwise, print \"?\" to report that the result is uncertain.\n\nExamples\n\nInput\n\n\n3 7 0\n\n\nOutput\n\n\n-\n\nInput\n\n\n2 0 1\n\n\nOutput\n\n\n+\n\nInput\n\n\n1 1 0\n\n\nOutput\n\n\n0\n\nInput\n\n\n0 0 1\n\n\nOutput\n\n\n?\n\nNote\n\nIn the first example, Nauuo would definitely get three upvotes and seven downvotes, so the only possible result is \"-\".\n\nIn the second example, no matter the person unknown downvotes or upvotes, Nauuo would get more upvotes than downvotes. So the only possible result is \"+\".\n\nIn the third example, Nauuo would definitely get one upvote and one downvote, so the only possible result is \"0\".\n\nIn the fourth example, if the only one person upvoted, the result would be \"+\", otherwise, the result would be \"-\". There are two possible results, so the result is uncertain.", "test_results": [{"status": "pass", "feedback": ""}, {"status": "pass", "feedback": ""}, {"status": "pass", "feedback": ""}, {"status": "pass", "feedback": ""}], "status": "pass"}
{"function_signature": "def findWinner (n : Nat) (teams : List String) : String", "property_name": "winner_prop", "property_def": "def countOccurrences (x : String) (xs : List String) : Nat :=\n  xs.foldl (fun acc s => if s == x then acc + 1 else acc) 0\n\ndef uniqueTeams (teams : List String) : List String :=\n  teams.foldl (fun acc s => if acc.contains s then acc else s::acc) []\n\ndef winner_prop (n : Nat) (teams : List String) (out : String) : Prop :=\n  let uniq := uniqueTeams teams\n  let counts := uniq.map (fun team => (team, countOccurrences team teams))\n  counts.length ≤ 2 ∧ \n  counts.length > 0 ∧\n  (∃ team count, counts.contains (team, count) ∧ team = out ∧\n    ∀ other_team other_count, counts.contains (other_team, other_count) → \n      other_count ≤ count)", "theorem_signature": "theorem winner_spec (n : Nat) (teams : List String) : winner_prop n teams (findWinner n teams)", "tests": ["1 [\"ABC\"] \"ABC\"", "5 [\"A\", \"ABA\", \"ABA\", \"A\", \"A\"] \"A\""], "description": "One day Vasya decided to have a look at the results of Berland 1910 Football Championship’s finals. Unfortunately he didn't find the overall score of the match; however, he got hold of a profound description of the match's process. On the whole there are n lines in that description each of which described one goal. Every goal was marked with the name of the team that had scored it. Help Vasya, learn the name of the team that won the finals. It is guaranteed that the match did not end in a tie.\n\nInput\n\nThe first line contains an integer n (1 ≤ n ≤ 100) — the number of lines in the description. Then follow n lines — for each goal the names of the teams that scored it. The names are non-empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.\n\nOutput\n\nPrint the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.\n\nExamples\n\nInput\n\n1\nABC\n\n\nOutput\n\nABC\n\n\nInput\n\n5\nA\nABA\nABA\nA\nA\n\n\nOutput\n\nA", "test_results": [{"status": "pass", "feedback": "/var/tmp/tmpc2dm908m/true.lean:10:25: warning: unused variable `n`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`"}, {"status": "pass", "feedback": "/var/tmp/tmpb36ftvo_/true.lean:10:25: warning: unused variable `n`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`"}], "status": "pass"}
{"function_signature": "def min_instability (n : Nat) (arr : Array Nat) : Nat", "property_name": "min_instability_prop", "property_def": "def array_max (arr : Array Nat) : Nat :=\n  arr.foldl (fun acc x => max acc x) 0\n\ndef array_min (arr : Array Nat) : Nat :=\n  arr.foldl (fun acc x => min acc x) (arr[0]!)\n\ndef instability (arr : Array Nat) : Nat :=\n  array_max arr - array_min arr\n\ndef remove_at (arr : Array Nat) (i : Nat) : Array Nat :=\n  (arr.extract 0 i).append (arr.extract (i+1) arr.size)\n\ndef min_instability_prop (n : Nat) (arr : Array Nat) (out : Nat) : Prop :=\n  n = arr.size ∧ \n  out = Id.run do\n    let mut min_inst := instability (remove_at arr 0)\n    for i in [1:n] do\n      let curr_inst := instability (remove_at arr i)\n      min_inst := min min_inst curr_inst\n    min_inst", "theorem_signature": "theorem min_instability_spec (n : Nat) (arr : Array Nat) : min_instability_prop n arr (min_instability n arr)", "tests": ["4 #[1,3,3,7] 2", "2 #[1,100000] 0"], "description": "You are given an array a consisting of n integer numbers.\n\nLet instability of the array be the following value: max_{i = 1}^{n} a_i - min_{i = 1}^{n} a_i.\n\nYou have to remove exactly one element from this array to minimize instability of the resulting (n-1)-elements array. Your task is to calculate the minimum possible instability.\n\nInput\n\nThe first line of the input contains one integer n (2 ≤ n ≤ 10^5) — the number of elements in the array a.\n\nThe second line of the input contains n integers a_1, a_2, ..., a_n (1 ≤ a_i ≤ 10^5) — elements of the array a.\n\nOutput\n\nPrint one integer — the minimum possible instability of the array if you have to remove exactly one element from the array a.\n\nExamples\n\nInput\n\n\n4\n1 3 3 7\n\n\nOutput\n\n\n2\n\n\nInput\n\n\n2\n1 100000\n\n\nOutput\n\n\n0\n\nNote\n\nIn the first example you can remove 7 then instability of the remaining array will be 3 - 1 = 2.\n\nIn the second example you can remove either 1 or 100000 then instability of the remaining array will be 100000 - 100000 = 0 and 1 - 1 = 0 correspondingly.", "test_results": [{"status": "pass", "feedback": ""}, {"status": "pass", "feedback": ""}], "status": "pass"}
{"function_signature": "def evenOddGame (n : Nat) : String", "property_name": "evenOddGame_prop", "property_def": "def isEven (n : Nat) : Bool := n % 2 = 0\n\ndef isValidMove (n : Nat) (isMahmoudTurn : Bool) (move : Nat) : Bool :=\n  move ≤ n && move > 0 && (isMahmoudTurn = isEven move)\n\ndef hasValidMove (n : Nat) (isMahmoudTurn : Bool) : Prop :=\n  ∃ m, isValidMove n isMahmoudTurn m = true\n\ndef isWinningPosition (n : Nat) (isMahmoudTurn : Bool) : Prop :=\n  n > 0 ∧ hasValidMove n isMahmoudTurn\n\ndef evenOddGame_prop (n : Nat) (result : String) : Prop :=\n  (result = \"Mahmoud\" ∧ isWinningPosition n true) ∨\n  (result = \"Ehab\" ∧ ¬isWinningPosition n true)", "theorem_signature": "theorem evenOddGame_spec (n : Nat) : evenOddGame_prop n (evenOddGame n)", "tests": ["1 \"Ehab\"", "2 \"Mahmoud\""], "description": "Mahmoud and Ehab play a game called the even-odd game. Ehab chooses his favorite integer n and then they take turns, starting from Mahmoud. In each player's turn, he has to choose an integer a and subtract it from n such that:\n\n  * 1 ≤ a ≤ n. \n  * If it's Mahmoud's turn, a has to be even, but if it's Ehab's turn, a has to be odd. \n\n\n\nIf the current player can't choose any number satisfying the conditions, he loses. Can you determine the winner if they both play optimally?\n\nInput\n\nThe only line contains an integer n (1 ≤ n ≤ 109), the number at the beginning of the game.\n\nOutput\n\nOutput \"Mahmoud\" (without quotes) if Mahmoud wins and \"Ehab\" (without quotes) otherwise.\n\nExamples\n\nInput\n\n1\n\n\nOutput\n\nEhab\n\nInput\n\n2\n\n\nOutput\n\nMahmoud\n\nNote\n\nIn the first sample, Mahmoud can't choose any integer a initially because there is no positive even integer less than or equal to 1 so Ehab wins.\n\nIn the second sample, Mahmoud has to choose a = 2 and subtract it from n. It's Ehab's turn and n = 0. There is no positive odd integer less than or equal to 0 so Mahmoud wins.", "test_results": [{"status": "pass", "feedback": ""}, {"status": "pass", "feedback": ""}], "status": "pass"}
{"function_signature": "def countRoomsForTwo (rooms: List (Nat × Nat)) : Nat", "property_name": "countRoomsForTwo_prop", "property_def": "def hasSpaceForTwo (room: Nat × Nat) : Bool :=\n  let (current, capacity) := room\n  capacity - current ≥ 2\n\ndef countRoomsForTwo_prop (rooms: List (Nat × Nat)) (out: Nat) : Prop := \n  out = (rooms.filter hasSpaceForTwo).length", "theorem_signature": "theorem countRoomsForTwo_spec (rooms: List (Nat × Nat)) : countRoomsForTwo_prop rooms (countRoomsForTwo rooms)", "tests": ["[(1,1), (2,2), (3,3)] 0", "[(1,10), (0,10), (10,10)] 2"], "description": "George has recently entered the BSUCP (Berland State University for Cool Programmers). George has a friend Alex who has also entered the university. Now they are moving into a dormitory. \n\nGeorge and Alex want to live in the same room. The dormitory has n rooms in total. At the moment the i-th room has pi people living in it and the room can accommodate qi people in total (pi ≤ qi). Your task is to count how many rooms has free place for both George and Alex.\n\nInput\n\nThe first line contains a single integer n (1 ≤ n ≤ 100) — the number of rooms.\n\nThe i-th of the next n lines contains two integers pi and qi (0 ≤ pi ≤ qi ≤ 100) — the number of people who already live in the i-th room and the room's capacity.\n\nOutput\n\nPrint a single integer — the number of rooms where George and Alex can move in.\n\nExamples\n\nInput\n\n3\n1 1\n2 2\n3 3\n\n\nOutput\n\n0\n\n\nInput\n\n3\n1 10\n0 10\n10 10\n\n\nOutput\n\n2", "test_results": [{"status": "pass", "feedback": ""}, {"status": "pass", "feedback": ""}], "status": "pass"}
{"function_signature": "def race_winner (s v1 v2 t1 t2 : Nat) : String", "property_name": "race_winner_prop", "property_def": "def get_total_time (s v t : Nat) : Nat :=\n  t + s * v + t\n\ndef winner_to_string (time1 time2 : Nat) : String :=\n  if time1 < time2 then \"First\"\n  else if time2 < time1 then \"Second\"\n  else \"Friendship\"\n\ndef race_winner_prop (s v1 v2 t1 t2 : Nat) (out : String) : Prop :=\n  let time1 := get_total_time s v1 t1\n  let time2 := get_total_time s v2 t2\n  out = winner_to_string time1 time2", "theorem_signature": "theorem race_winner_spec (s v1 v2 t1 t2 : Nat) : race_winner_prop s v1 v2 t1 t2 (race_winner s v1 v2 t1 t2)", "tests": ["5 1 2 1 2 \"First\"", "3 3 1 1 1 \"Second\"", "4 5 3 1 5 \"Friendship\""], "description": "Two boys decided to compete in text typing on the site \"Key races\". During the competition, they have to type a text consisting of s characters. The first participant types one character in v1 milliseconds and has ping t1 milliseconds. The second participant types one character in v2 milliseconds and has ping t2 milliseconds.\n\nIf connection ping (delay) is t milliseconds, the competition passes for a participant as follows: \n\n  1. Exactly after t milliseconds after the start of the competition the participant receives the text to be entered. \n  2. Right after that he starts to type it. \n  3. Exactly t milliseconds after he ends typing all the text, the site receives information about it. \n\n\n\nThe winner is the participant whose information on the success comes earlier. If the information comes from both participants at the same time, it is considered that there is a draw.\n\nGiven the length of the text and the information about participants, determine the result of the game.\n\nInput\n\nThe first line contains five integers s, v1, v2, t1, t2 (1 ≤ s, v1, v2, t1, t2 ≤ 1000) — the number of characters in the text, the time of typing one character for the first participant, the time of typing one character for the the second participant, the ping of the first participant and the ping of the second participant.\n\nOutput\n\nIf the first participant wins, print \"First\". If the second participant wins, print \"Second\". In case of a draw print \"Friendship\".\n\nExamples\n\nInput\n\n5 1 2 1 2\n\n\nOutput\n\nFirst\n\n\nInput\n\n3 3 1 1 1\n\n\nOutput\n\nSecond\n\n\nInput\n\n4 5 3 1 5\n\n\nOutput\n\nFriendship\n\nNote\n\nIn the first example, information on the success of the first participant comes in 7 milliseconds, of the second participant — in 14 milliseconds. So, the first wins.\n\nIn the second example, information on the success of the first participant comes in 11 milliseconds, of the second participant — in 5 milliseconds. So, the second wins.\n\nIn the third example, information on the success of the first participant comes in 22 milliseconds, of the second participant — in 22 milliseconds. So, it is be a draw.", "test_results": [{"status": "pass", "feedback": ""}, {"status": "pass", "feedback": ""}, {"status": "pass", "feedback": ""}], "status": "pass"}
{"function_signature": "def findPoint (n k : Nat) (squares : Array Nat) : Option (Nat × Nat × Bool)", "property_name": "findPoint_prop", "property_def": "def inSquare (x y a : Nat) : Bool :=\n  x <= a && y <= a\n\ndef countSquares (x y : Nat) (squares : Array Nat) : Nat :=\n  squares.foldl (fun count a => if inSquare x y a then count + 1 else count) 0\n\ndef findPoint_prop (n k : Nat) (squares : Array Nat) (res : Option (Nat × Nat × Bool)) : Prop :=\n  match res with\n  | none => ∀ x y : Nat, countSquares x y squares ≠ k\n  | some (x, y, false) => countSquares x y squares = k ∧ \n                         x ≤ 1000000000 ∧ y ≤ 1000000000\n  | some (_, _, true) => false", "theorem_signature": "theorem findPoint_spec (n k : Nat) (squares : Array Nat) : findPoint_prop n k squares (findPoint n k squares)", "tests": ["3 1 #[2,4,1] (some (4,0,false))", "4 3 #[5,1,3,4] (some (2,1,false))", "4 50 #[5,1,10,2] none"], "description": "Vasya has found a piece of paper with a coordinate system written on it. There are n distinct squares drawn in this coordinate system. Let's number the squares with integers from 1 to n. It turned out that points with coordinates (0, 0) and (ai, ai) are the opposite corners of the i-th square.\n\nVasya wants to find such integer point (with integer coordinates) of the plane, that belongs to exactly k drawn squares. We'll say that a point belongs to a square, if the point is located either inside the square, or on its boundary. \n\nHelp Vasya find a point that would meet the described limits.\n\nInput\n\nThe first line contains two space-separated integers n, k (1 ≤ n, k ≤ 50). The second line contains space-separated integers a1, a2, ..., an (1 ≤ ai ≤ 109).\n\nIt is guaranteed that all given squares are distinct.\n\nOutput\n\nIn a single line print two space-separated integers x and y (0 ≤ x, y ≤ 109) — the coordinates of the point that belongs to exactly k squares. If there are multiple answers, you are allowed to print any of them. \n\nIf there is no answer, print \"-1\" (without the quotes).\n\nExamples\n\nInput\n\n4 3\n5 1 3 4\n\n\nOutput\n\n2 1\n\n\nInput\n\n3 1\n2 4 1\n\n\nOutput\n\n4 0\n\n\nInput\n\n4 50\n5 1 10 2\n\n\nOutput\n\n-1", "test_results": [{"status": "pass", "feedback": "/var/tmp/tmp02l9gy7b/true.lean:10:28: warning: unused variable `n`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`"}, {"status": "pass", "feedback": "/var/tmp/tmpre2kfqgo/true.lean:10:28: warning: unused variable `n`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`"}, {"status": "pass", "feedback": "/var/tmp/tmpro6pftk4/true.lean:10:28: warning: unused variable `n`\nnote: this linter can be disabled with `set_option linter.unusedVariables false`"}], "status": "pass"}
{"function_signature": "def dice_game (a b : Nat) : Nat × Nat × Nat", "property_name": "count_outcomes_prop", "property_def": "def abs_diff (x y : Nat) : Nat :=\n  if x ≥ y then x - y else y - x\n\ndef is_closer (player other dice : Nat) : Bool :=\n  abs_diff player dice < abs_diff other dice\n\ndef is_equal_dist (player other dice : Nat) : Bool :=\n  abs_diff player dice = abs_diff other dice\n\ndef count_outcomes_prop (a b first draw second : Nat) : Prop :=\n  first + draw + second = 6 ∧\n  first = ((List.range 6).filter (fun d => is_closer a b (d+1))).length ∧\n  draw = ((List.range 6).filter (fun d => is_equal_dist a b (d+1))).length ∧\n  second = ((List.range 6).filter (fun d => is_closer b a (d+1))).length", "theorem_signature": "theorem dice_game_spec (a b : Nat) : let (first, draw, second) := dice_game a b; count_outcomes_prop a b first draw second", "tests": ["2 5 3 0 3", "2 4 2 1 3"], "description": "Two players are playing a game. First each of them writes an integer from 1 to 6, and then a dice is thrown. The player whose written number got closer to the number on the dice wins. If both payers have the same difference, it's a draw.\n\nThe first player wrote number a, the second player wrote number b. How many ways to throw a dice are there, at which the first player wins, or there is a draw, or the second player wins?\n\nInput\n\nThe single line contains two integers a and b (1 ≤ a, b ≤ 6) — the numbers written on the paper by the first and second player, correspondingly.\n\nOutput\n\nPrint three integers: the number of ways to throw the dice at which the first player wins, the game ends with a draw or the second player wins, correspondingly.\n\nExamples\n\nInput\n\n2 5\n\n\nOutput\n\n3 0 3\n\n\nInput\n\n2 4\n\n\nOutput\n\n2 1 3\n\nNote\n\nThe dice is a standard cube-shaped six-sided object with each side containing a number from 1 to 6, and where all numbers on all sides are distinct.\n\nYou can assume that number a is closer to number x than number b, if |a - x| < |b - x|.", "test_results": [{"status": "pass", "feedback": ""}, {"status": "pass", "feedback": ""}], "status": "pass"}
